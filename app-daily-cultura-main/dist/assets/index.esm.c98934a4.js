import{l as o}from"./index.c93647e1.js";function x(r){return typeof r=="function"}function z(r){return r!==null&&typeof r=="object"&&!Array.isArray(r)}function y(r){return x(r.$validator)?Object.assign({},r):{$validator:r}}function N(r){return typeof r=="object"?r.$valid:r}function T(r){return r.$validator||r}function L(r,e){if(!z(r))throw new Error(`[@vuelidate/validators]: First parameter to "withParams" should be an object, provided ${typeof r}`);if(!z(e)&&!x(e))throw new Error("[@vuelidate/validators]: Validator must be a function or object with $validator parameter");const t=y(e);return t.$params=Object.assign({},t.$params||{},r),t}function V(r,e){if(!x(r)&&typeof o(r)!="string")throw new Error(`[@vuelidate/validators]: First parameter to "withMessage" should be string or a function returning a string, provided ${typeof r}`);if(!z(e)&&!x(e))throw new Error("[@vuelidate/validators]: Validator must be a function or object with $validator parameter");const t=y(e);return t.$message=r,t}function R(r){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[];const t=y(r);return Object.assign({},t,{$async:!0,$watchTargets:e})}function S(r){return{$validator(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];return o(e).reduce((i,c,b)=>{const f=Object.entries(c).reduce((d,s)=>{let[l,w]=s;const E=r[l]||{},v=Object.entries(E).reduce((u,M)=>{let[O,j]=M;const g=T(j).call(this,w,c,b,...n),p=N(g);if(u.$data[O]=g,u.$data.$invalid=!p||!!u.$data.$invalid,u.$data.$error=u.$data.$invalid,!p){let h=j.$message||"";const P=j.$params||{};typeof h=="function"&&(h=h({$pending:!1,$invalid:!p,$params:P,$model:w,$response:g})),u.$errors.push({$property:l,$message:h,$params:P,$response:g,$model:w,$pending:!1,$validator:O})}return{$valid:u.$valid&&p,$data:u.$data,$errors:u.$errors}},{$valid:!0,$data:{},$errors:[]});return d.$data[l]=v.$data,d.$errors[l]=v.$errors,{$valid:d.$valid&&v.$valid,$data:d.$data,$errors:d.$errors}},{$valid:!0,$data:{},$errors:{}});return{$valid:i.$valid&&f.$valid,$data:i.$data.concat(f.$data),$errors:i.$errors.concat(f.$errors)}},{$valid:!0,$data:[],$errors:[]})},$message:e=>{let{$response:t}=e;return t?t.$errors.map(n=>Object.values(n).map(a=>a.map(i=>i.$message)).reduce((a,i)=>a.concat(i),[])):[]}}}const $=r=>{if(r=o(r),Array.isArray(r))return!!r.length;if(r==null)return!1;if(r===!1)return!0;if(r instanceof Date)return!isNaN(r.getTime());if(typeof r=="object"){for(let e in r)return!0;return!1}return!!String(r).length},A=r=>(r=o(r),Array.isArray(r)?r.length:typeof r=="object"?Object.keys(r).length:String(r).length);function m(){for(var r=arguments.length,e=new Array(r),t=0;t<r;t++)e[t]=arguments[t];return n=>(n=o(n),!$(n)||e.every(a=>a.test(n)))}var X=Object.freeze({__proto__:null,withParams:L,withMessage:V,withAsync:R,forEach:S,req:$,len:A,regex:m,unwrap:o,unwrapNormalizedValidator:T,unwrapValidatorResponse:N,normalizeValidatorObject:y});m(/^[a-zA-Z]*$/);var D=m(/^[a-zA-Z0-9]*$/),Y={$validator:D,$message:"The value must be alpha-numeric",$params:{type:"alphaNum"}},F=m(/^\d*(\.\d+)?$/),_={$validator:F,$message:"Value must be numeric",$params:{type:"numeric"}};const U=/^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;var Z=m(U),k={$validator:Z,$message:"Value is not a valid email address",$params:{type:"email"}};function I(r){return e=>!$(e)||A(e)<=o(r)}function rr(r){return{$validator:I(r),$message:e=>{let{$params:t}=e;return`The maximum length allowed is ${t.max}`},$params:{max:r,type:"maxLength"}}}function B(r){return e=>!$(e)||A(e)>=o(r)}function er(r){return{$validator:B(r),$message:e=>{let{$params:t}=e;return`This field should be at least ${t.min} characters long`},$params:{min:r,type:"minLength"}}}function C(r){return typeof r=="string"&&(r=r.trim()),$(r)}var tr={$validator:C,$message:"Value is required",$params:{type:"required"}};const q=(r,e)=>r?!0:$(typeof e=="string"?e.trim():e);function G(r){return function(e,t){if(typeof r!="function")return q(o(r),e);const n=r.call(this,e,t);return q(n,e)}}function ar(r){return{$validator:G(r),$message:"The value is required",$params:{type:"requiredUnless",prop:r}}}const H=/^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u00a1-\uffff][a-z0-9\u00a1-\uffff_-]{0,62})?[a-z0-9\u00a1-\uffff]\.)+(?:[a-z\u00a1-\uffff]{2,}\.?))(?::\d{2,5})?(?:[/?#]\S*)?$/i;m(H);function J(r){return e=>!$(e)||(!/\s/.test(e)||e instanceof Date)&&+e>=+o(r)}function nr(r){return{$validator:J(r),$message:e=>{let{$params:t}=e;return`The minimum value allowed is ${t.min}`},$params:{min:r,type:"minValue"}}}function K(r){return e=>!$(e)||(!/\s/.test(e)||e instanceof Date)&&+e<=+o(r)}var ir=r=>({$validator:K(r),$message:e=>{let{$params:t}=e;return`The maximum value allowed is ${t.max}`},$params:{max:r,type:"maxValue"}});m(/(^[0-9]*$)|(^-[0-9]+$)/);m(/^[-]?\d*(\.\d+)?$/);function sr(r){let{t:e,messagePath:t=a=>{let{$validator:i}=a;return`validations.${i}`},messageParams:n=a=>a}=r;return function(i){let{withArguments:c=!1,messagePath:b=t,messageParams:f=n}=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};function d(s){return e(b(s),f(Object.assign({model:s.$model,property:s.$property,pending:s.$pending,invalid:s.$invalid,response:s.$response,validator:s.$validator,propertyPath:s.$propertyPath},s.$params)))}return c&&typeof i=="function"?function(){return V(d,i(...arguments))}:V(d,i)}}export{rr as a,ir as b,sr as c,nr as d,k as e,X as f,Y as g,ar as h,er as m,_ as n,tr as r};
